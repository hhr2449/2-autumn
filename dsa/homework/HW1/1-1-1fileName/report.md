## 算法思路和实现要点

1. 设定字符串的长度为状态变量，这里涉及两个字符串之间的转移，所以分别设定m,n为A，B字符串的字串长度

2. 题目要求编辑距离，那么可以使用二维dp，设`f[m][n]`为将A的前m个字符转化为B的前面n个字符的编辑距离

3. 转移方程：考虑`f[i][j]`的求解。假设f数组前面的元素已经求得，现在要求`f[i][j]`，

   * 如果$A[i-1][j-1] == B[i-1][j-1]$，那么无需额外操作，可得到`f[i][j] = f[i-1][j-1]`

   * 如果不等，则有两种方式可以实现A中前i个字符转化为B中前j个字符：

     1. 将A中第i个字符删除掉：此时需要将$A[:i-1]转化为B[:j]$，则此时时间成本为`f[i-1][j] + 1`

     2. 在A中插入B中的第j个字符：此时需要将$A[:i]转化为B[:j-1]$，此时时间成本为`f[i][j-1] + 1`

     3. 则不等的情况中$f[i][j] = min\{f[i-1][j],f[i][j-1]\}+1$

4. 初始条件：

   - `f[0][0] = 0`（空字符串转换为空字符串无需操作）
   - `f[0][j] = j`（空字符串转换为 B 的前 j 个字符需要 j 次插入）
   - `f[i][0] = i`（A 的前 i 个字符转换为空字符串需要 i 次删除）

则由上面的条件可以使用迭代来求出`f[m][n]`，即为所求

优化：

如果直接求解，那么时间复杂度为$O(mn)$，空间复杂度也为$O(mn)$，无法满足条件

1. 空间优化：最终的目标是求解$f[m][n]$，并且求解$f[i][j]$只需要前一行数据，所以不需要储存所有的数据，只需要开一个$2\times n$的数组，第一行是上一行的数据，第二行是当前求解行的数据，这样空间复杂度可以优化到$O(n)$级别

1. 时间优化：注意到题目给出了一个限制条件：只要编辑距离大于k的直接输出-1。所以对于一些可以确定已经大于k的部分可以直接剪枝

   对于两个字符串，其编辑距离一定是大于等于字符串长度的差，所以对于第i行来说，可以定义$start=max\{0, i-k\}，end=min\{n-1, i+k\}$，那么只有`[start, end]`范围内的值需要求解
   
   

## 渐进时间复杂度的分析

算法的时间复杂度的来源主要是动态规划数组的计算。原动态规划算法需遍历所有 i（1~m）和 j（1~n），时间复杂度为$O(mn)$

优化后，只需要计算可能小于等于k的部分，每行最多只需要计算2k次，每行的计算时间复杂度为$O(k)$，一共计算m行，所以总体的时间复杂度为$O(km)$

## 渐进空间复杂度的分析

算法的空间消耗主要来自动态规划数组的存储。原始动态规划思路需构建 mn 的二维数组，空间复杂度为$O(mn)$，不适用于大规模字符串。

优化后，利用两行数组交替存储计算结果：一行保存上一轮计算的结果（i-1 行），另一行存储当前轮计算的结果（i 行）。每行数组的长度为 n+1（n 为字符串 B 的长度），总空间占用为 2×(n+1)。

忽略常数系数和低阶项后，空间消耗与字符串 B 的长度 n 呈线性关系。当问题规模（字符串长度）无限增长时，程序占用空间随 n 线性增长，故渐进空间复杂度为 O (n)。

## 遇到的困难和解决方法

1. 动态规划思路的建立，如何设置状态变量和建立转移方程
   * 先明确核心目标是 “最小操作数”，故状态变量设为`f[i][j]`（A 前 i 个字符转 B 前 j 个字符的操作数）
   * 再拆解操作逻辑：字符相等时继承前一状态（`f[i-1][j-1]`），不等时仅需二选一（删 A 字符对应`f[i-1][j]`，插 B 字符对应`f[i][j-1]`）
   * 通过实例验证，多试几个然后猜测规律
2. 空间的优化
3. 时间的优化
   * 观察题目条件，发现额外条件k，从而想到可以使用k来进行剪枝

## 估计完成本题所用时间 
3小时

## 关于本题的更多感想
