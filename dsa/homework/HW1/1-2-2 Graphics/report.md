## 算法思路和实现要点

1. 如何连接给出的线段：

   题目要求给定的线段之间两两不相交，而且线段的两个端点是在x,y轴的正半轴上的。那么实际上只需要将给出的x，y轴上的点的数组`pointX`,`pointY`进行排序，然后将相同下标的点进行两两连接即可

2. 排序算法的实现：可以使用快排：选定一个元素（可以选范围内的第一个元素）作为pivot，然后将大于pivot的元素都放到其左边，小于的元素放到右边（可以使用双指针，左指针寻找大于pivot的元素，放在右指针指向的位置，右指针寻找小于的元素，放在左指针指向的位置）。再利用递归分别处理左右两个部分

3. 判断给定点s确定的线段os是否经过某条线段：设x轴上的点为p，y轴上的点为q，那么让给定点s对向量pq,进行toleft检测(也就是计算$$
\begin{vmatrix}
x_p & y_p & 1 \\
x_q & y_q & 1 \\
x_s & y_s & 1 \\
\end{vmatrix}
$$)，如果结果为正，说明s在向量pq的左侧，也就是不经过pq

4. 如何进行查找：只要确定点在那两个线段之间即可，可以使用binary search，如果判断该点在某个线段的左边则向左边查找，右边同理

## 渐进时间复杂度的分析

算法主要包括的过程有：

1. 排序
2. 二分查找
3. 计算os是否经过某条线段



1. 判断是否经过线段使用了toleft test，为常数级时间复杂度$O(1)$

2. 排序阶段使用了快速排序，分析如下：

   分区操作：需要遍历当前指定的范围，复杂度为$O(n)$

   理想情况下，每次选区都可以等分，则递归深度为`logn`，整体时间复杂度为$O(nlogn)$

   最坏情况下，每次选取都分成1，n-1，则递归深度为n，整体时间复杂度为$O(n^2)$

   平均情况下，递归深度为$O(logn)$，整体时间复杂度为$O(nlogn)$

3. 二分查找过程：

   二分查找中，每次比较都可以将解空间减半，则$2^x=n$可解得$x=logn$，也就是每次查找的时间复杂度为$O(logn)$，要进行m次查询，则时间复杂度为$O(mlogn)$

4. 总结：

   当问题规模 n, m → ∞ 时：

   * 平均情况：时间复杂度增长趋势为 O((n + m) log n)
   * 最坏情况：时间复杂度增长趋势为 O(n² + m log n)

## 渐进空间复杂度的分析

1. 排序阶段的空间使用：

   * 排序阶段会使用栈空间：

     最差情况：递归深度为n，则空间复杂度为$O(n)$

     平均情况：递归深度为$logn$，空间复杂度为$O(logn)$

   * 分区操作：使用双指针原地操作，空间复杂度为$O(1)$

2. 查询阶段的空间复杂度：

   使用迭代进行实现，不消耗额外的空间，空间复杂度为$O(1)$

3. 辅助变量的使用：

   再toleft计算，查询，排序中用到了一些辅助变量，空间复杂度为$O(1)$

4. 总结：

   该算法的空间复杂度主要来自于排序过程中的递归栈空间的使用，最坏空间复杂度为$O(n)$，平均空间复杂度为$O(logn)$

## 遇到的困难和解决方法

1. 二分查找过程边界条件复杂

   将查找过程分解成不同的情况，将一些边界情况（比如没有经过线段，经过所有线段）提前进行判断，简化查找过程

2. 给出的数据较大，会发生溢出

   记得使用long long

## 估计完成本题所用时间 

2 小时

## 关于本题的更多感想
