# chapter 1

## 算法的要素

* 输入：待处理的信息（问题）
* 输出：经处理的信息（答案）
* 正确：算法具有正确性
* 明确：可描述为一个基本操作组成的序列（明确可复现）
* 可行：每一个基本操作都可以实现，且**在常数时间内完成**
* 有穷：对于任何输入，经过有限次基本操作，都可以得到输出

### 有穷性

![image-20250915102707460](https://raw.githubusercontent.com/hhr2449/pictureBed/main/img/image-20250915102707460.png)

每次生成随机数，出现奇数和偶数的概率均为50%

当`rand()&1 == 0`时结束

理论上来说可能出现任意多次不结束

但是不结束的概率及其小，可以认为一定能结束，是一个算法



### 冒泡排序

![image-20250915103322276](https://raw.githubusercontent.com/hhr2449/pictureBed/main/img/image-20250915103322276.png)

正确性分析：要求对于任意规模的输入数据都需要能够正确处理，因此需要进行理论上的分析与证明

冒泡排序：进行n次扫描，从前向后进行扫描，如果前后两个元素是前面大于后面，则交换，否则不变

可以确定，每次扫描中至少可以保证当前扫描的序列中最大的一定会到最后面

![image-20250915104546812](https://raw.githubusercontent.com/hhr2449/pictureBed/main/img/image-20250915104546812.png)

证明：



### 好的算法

![image-20250915104938638](https://raw.githubusercontent.com/hhr2449/pictureBed/main/img/image-20250915104938638.png)

1. 健壮性
2. 可读性
3. **效率**：速度尽可能快，内存占用尽可能少



### 衡量算法的效率

#### 特定算法的效率衡量

![image-20250915105237862](https://raw.githubusercontent.com/hhr2449/pictureBed/main/img/image-20250915105237862.png)

对于特定的算法，可以使用：用算法A来计算一个规模为n的实力所需的计算成本

但是对于同个规模的数据来说，计算的效率差异较大

一般使用规模同为n的所有实例中最坏的实例来进行衡量

$$T(n) = max\{T(P) | |P| = n\}$$

#### 特定问题的效率衡量

![image-20250915105758128](https://raw.githubusercontent.com/hhr2449/pictureBed/main/img/image-20250915105758128.png)

同一份算法，使用不同的语言，编译器，计算机会出现不同的运行效率，所以应该使用一个理想的平台来进行衡量，而非进行试验计算

##### 图灵机程序

将一个算法使用图灵机程序表示，使用图灵机上执行的步数来衡量算法的好坏，而不是执行的时间

二进制数加1的图灵机程序：

![image-20250915110514672](https://raw.githubusercontent.com/hhr2449/pictureBed/main/img/image-20250915110514672.png)

1. 左行，将接触到的1全部变成0
2. 如果遇到0，则将0变成1，右转；如果遇到#，则将其变成1，右转
3. 右行，遇到#停止

##### RAM机程序（random access machine）

1. 寄存器顺序编号，总数没有限制
2. 可以通过编号直接访问任意寄存器
3. IR：指示当前正在执行那条指令
4. 每一次基本操作需要常数时间

![image-20250915111927243](https://raw.githubusercontent.com/hhr2449/pictureBed/main/img/image-20250915111927243.png)

可认为算法的运行时间正比于算法执行需要的基本操作次数

T(n) = 算法求解规模为n的问题，所需执行的基本操作的次数



##### 渐进复杂度

1. 使用之前的计算模型来衡量过于复杂
2. 对于计算机而言，一些微小的差别可以不用考虑
3. 更关心**问题的规模足够大**的时候，计算成本的增长趋势（考虑n无穷大的时候的性能）

###### 大O表示法：

![image-20250915112603716](https://raw.githubusercontent.com/hhr2449/pictureBed/main/img/image-20250915112603716.png)